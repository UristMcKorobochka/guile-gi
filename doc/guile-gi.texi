\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename guile-gi.info
@settitle Guile GI
@c %**end of header
@include version.texi

@copying
Copyright @copyright{} 2018, 2019 Michael L. Gran

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.  A copy of the license is included in the section entitled ``GNU
Free Documentation License''.
@end copying

@titlepage
@title Guile GI
@subtitle Version @value{VERSION}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@c @ifnottex
@node Top
@top Guile GI

This manual is for Guile GI @value{VERSION}.
@c @end ifnottex

@menu
* Preface::
* Getting Started::
* Tutorials::
* Reference Guide::
* Further Resources and Contact Info::
* GNU Free Documentation License::
* Index::

@detailmenu
--- The Detailed Node Listing ---

Getting Started

* Installation::
* Sample Applications::

Sample Applications

* Example 1::

Tutorials

* GObject Types and Guile Types::
* Threads and Concurrency::
* Debugging and Profiling::
* Application Deployment::
* Testing and Continuous Integration::

Reference Guide

* Typelib Introspection::
* Typelib Documentation::
* GObject Types::
* GType::
* GObject Methods::
* GObject Signals::
* GObject Properties::
* Custom GObjects::              Defining new GObject classes
* Enums and Flags::
* Utilities::
* More Stuff::

@end detailmenu
@end menu

@node Preface
@unnumbered Preface

Guile GI is a Guile package that hopes to provide access for
GObject-based libraries such as GTK+, GLib, WebKitGTK+ and many more.

It supports GNU/Linux, and has only been tested with Guile-2.2. Guile
GI is licensed under the LGPLv2.1+. This documentation is licensed under
the FDLv1.3+.

If you want to write a Guile application for GNOME or a Guile GUI
application using GTK+, then Guile GI (when it is finished) will be
the way to go.

@node Getting Started
@chapter Getting Started

@quotation Warning
Guile-GI is still in its experimental phase and even so, this documentation
describes features of vastly different age. Don't be too surprised if something breaks.
@end quotation

To get things started, we will try to run a very simple GTK+ based GUI
application using the bindings provided by Guile GI.

Now, to understand how this works, one needs to distinguish between
what Guile-GI provides and the bindings that it creates.

@itemize
@item
Guile-GI itself is a library that allows you to parse @code{typelib}
files, which describe code modules.  It has a handful of procedures
for inspecting @code{typelib} files as well as some helper procedures
for dynamically creating procedures and types.
@item
When Guile-GI is used, it creates procedures, variables, and types
according to the instructions in the @code{typelib} files.  These are
created @emph{at runtime} when the Guile-GI procedure
@code{typelib-load} is called.
@end itemize

First, for each GObject library that you want to use in your program,
you need to have an export library.  A sample library for GTK+3 could
take the following form.

@example
@include gtk-3.scm
@end example

Alternatively, you can instruct Guile-GI to create these modules for you, as
shown in the following.

@example
(use-modules (gi))
(use-typelibs ("GLib" "2.0") ("Gtk" "3.0"))
@end example

Here, Guile-GI creates the (hopefully unique) modules @code{(%gi GLib-2.0)} and @code{(%gi Gtk-3.0)}
and imports them into the current module using @code{use-modules}.

You will likely need some documentation for these auto-generated libraries.
We'd like to point you to the respective C documentation, but it is not really
apparent from that alone, which methods you can call from Scheme and how.
To bridge this gap, we've added some documentation functionality.
Consider a file @file{doc.scm} with roughly the following contents:

@example
#!/path/to/guile
(use-modules (gi documentation))

(let ((%typelib (typelib "GObject" "2.0"))
      (%gir (false-if-exception (gir "GObject" "2.0")))
      (%doc '()))
  (set! %doc (parse %typelib %doc))
  (close %typelib)
  (when %gir
    (set! %doc (parse %gir %doc))
    (close %gir))
  (->guile-procedures.txt %doc))
@end example

When @file{doc.scm} is executed by Guile, it will read both the information available in the
GIR metadata XML and runtime information created by Guile-GI, merging them into a single structure.
This structure can then be post-processed to generate the actual documentation.
Right now, we only offer the function @code{->guile-procedures.txt}, which generates content mimicking the
style of @file{guile-procedures.txt} files, such as @file{/usr/share/guile/2.2/guile-procedures.txt}.
Use shell pipes to redirect them into a file.

@xref{Typelib Introspection} for more information about @code{typelib->module} and
@ref{Typelib Documentation} for more information about @code{(gi documentation)}.

A minimal GTK application looks like this

@example
@include example-1.scm
@end example

When it is run, it will create an empty window with a title.  Are you impressed?

Let's walk through this example. Before the actual code, you see a ``header'' of
@code{require}s and @code{load-by-name}s. These procedures are imported from
@code{(gi repository)} and allow fine-grained loading of classes and functions into the
current namespace.
You could also load them using @code{use-typelibs} as shown above, but
this approach is significantly faster for large libraries such as GTK+.

Next, you may notice two important procedures -- @code{make} and @code{connect} --
as well as a few types, such as @code{<GtkApplication>} and @code{<GtkApplicationWindow>}.
These procedures and types allow you to interact with GObject's very odd class system.

First is @code{make}, which wraps and extends the @code{make} procedure found in GOOPS.
@xref{GOOPS,,,guile,The Guile reference manual} for infos about GOOPS.
In short the arguments, that would normally be used for slot initialization are instead used
to initialize properties.
This is an important distinction, as objects are represented in Scheme as GOOPS objects, whose
slots @strong{do not} map to properties.
It also takes care of some types, which do not derive from GObject, such as boxed types.

Next is @code{connect}, which connects Guile procedures as handlers to GObject signals.
Signals are roughly equal to hooks in Guile, except that they have an invisible default
handler and hence two @code{connect} methods instead of a single @code{add-hook!} one.
Removing a connection also requires temporarily saving the return value (which is an integer id),
so that it can be passed to @code{signal-handler-disconnect}.

Finally, we have the types. These are quite straight-forward in most cases, as there is
a direct mapping from GObject type to Guile type.
@xref{GObject Types} on this mapping.

@xref{GObject Methods} on how to use methods,
@ref{GObject Signals} on how to use signals and
@ref{GObject Properties} on how to use properties.

@menu
* Installation::
* Sample Applications::
@end menu

@node Installation
@section Installation

In some happy future, you might be able to get this from whatever method
your operating system normally uses to download free software.

If you are trying to build this from the Git repository, use
@command{git clone} to copy the tree onto your computer. After closing
the repository, you need to run @command{autoreconf} to generate a
@file{configure} file.

If you are building from a @file{guile-gi.zip} file or a
@file{guile-gi.tar.gz}, unpack the file.

From there, running @command{configure}, then @command{make}, then
@command{sudo make install} will give you a running system.

In the file archives, look for files named @file{INSTALL} for detailed
instructions.

@node Sample Applications
@section Sample Applications

@menu
* Example 1::
@end menu

@node Example 1
@subsection Example 1

@node Tutorials
@chapter Tutorials

@menu
* GObject Types and Guile Types::
* Threads and Concurrency::
* Debugging and Profiling::
* Application Deployment::
* Testing and Continuous Integration::
@end menu

@node GObject Types and Guile Types
@section GObject Types and Guile Types

Every time you call a GObject procedure provided by Guile-GI, the
Guile arguments need to be converted to C arguments, and the return
values need to be converted back into Guile values. For integer and
string arguments, the C to Guile conversions are straightforward; for
GObject types -- such as GTK's @code{GtkWindow} or @code{GtkButton} or
GLib's @code{GDate} -- a Guile object needs to be converted into a C
structure.  Hopefully, in normal circumstances, this conversion will
happen automatically without difficulty.

GObject types have different categories.  Some are simple C structs
and unions.  Others are @emph{objects}, which is GObject's class
hierarchy upon which the windowing library GTK is built.

Explaining how Guile-to-C type conversion is accomplished under the
hood can be slightly confusing because there are several different
things named `type':

@enumerate
@item
the C typedef of a structure, union or object, such as @code{struct GtkWindow}
@item
the C @code{GType}, a unique integer ID that GObject libraries provide
for each C typedef'd structure, union, or object
@item
the Guile class @code{<GType>} created by Guile-GI for each GType to hold instances
of the associated C structure
@end enumerate

For example, GLib has a type @code{GDate *} which holds information
about a calendar date.  The @code{GDate *} typedef has an associated
@code{GType} integer ID.  The Guile class @code{<Date>} is created to
hold structures with that @code{GType}.  When using GLib's date
functions from Guile, instances of @code{GDate *} are held by
instances of the Guile class @code{<Date>}.

Internally to Guile-GI, all of the Guile classes for GObject structs,
objects and unions are GOOPS types that handle managing the C pointer.
The C pointer is ``hidden'' in the @code{ptr} slot of an object.

@node Threads and Concurrency
@section Threads and Concurrency

While Guile is multi-threaded, applications using Guile-GI are not
fully thread-safe.  Notably, applications using GTK or GLib's mainloop
need all rendering and mainloop activities to occur in one thread.
Also, all calls to @code{typelib-load} need to be made from the same
thread.

@node Debugging and Profiling
@section Debugging and Profiling

Guile-GI makes use of GLib's debug logging.  Running a program with
the @env{G_MESSAGES_DEBUG} environment variable set to @code{all} will
provide a full trace of the function calls in Guile-GI.  For more
information on how to take advantage of this logging, see
@uref{https://developer.gnome.org/glib/stable/glib-running.html}.

@node Application Deployment
@section Application Deployment

If you write a program in Guile-GI and wish to share it
with the world, you will need to ensure your users have
all the prerequisites.

At a minimum, Guile-GI scripts will require that users have the
following packages.
@itemize
@item Guile
@item Guile-GI
@item libffi
@item GLib
@item GObject-Introspection aka GIRepository
@end itemize

And then, of course, a Guile-GI program will additionally
require whatever libraries its uses (GTK, WebKit2) as well
as their associated typelib files.

FIXME: Write about a good directory structure for a GTK application.

FIXME: Write about what to do with all the various GTK icons and XML
files.

@node Testing and Continuous Integration
@section Testing and Continuous Integration

The distribution does contain a couple of scripts that should enable it
to be built by Travis-CI.  In the root directory, there is a
@code{.travis.yml} and a @code{Dockerfile} that work together.  The
docker container pulls the latest version of Ubuntu, and the YML file
builds the project and runs @code{make distcheck}.

@node Reference Guide
@chapter Reference Guide

The Guile GI project provides a Guile module @file{(gi)}.  The
@file{(gi)} module is an interface for dynamically creating Guile
modules for GObject-based libraries by examining the information in
their @file{.typelib} files.

@c -----------------------------------------------------------------
@menu
* Typelib Introspection::
* Typelib Documentation::
* GObject Types::
* GType::
* GObject Methods::
* GObject Signals::
* GObject Properties::
* Custom GObjects::              Defining new GObject classes
* Enums and Flags::
* Utilities::
* More Stuff::
@end menu

@c -----------------------------------------------------------------
@node Typelib Introspection
@section Typelib Introspection

A GObject typelib file contains information on the public classes,
functions, and variables in a GObject-based library, and most
GObject-complient libraries, such as GLib and GTK, provide one.
Usually these files are on the filesystem in a single directory
location.  On Fedora, for example, these files may be stored in
@file{/var/lib64/girepository-1.0}.

All functions outlined in this section are part of @code{(gi repository)}
and are not re-exported by @code{(gi)}.

@deffn Procedure require lib [version]
Forces the namespace @var{lib} to be loaded if it isn't already.
This step is required once per @var{lib} before any other functionality
of this module is used.
If @var{version} is given, loads that version, otherwise loads the latest available.

Throws an error, if the library could not be found or loaded.
@end deffn

@deffn Procedure get-search-path
This returns the current search path used to find typelib files as a list of strings.

If it returns an empty list, this indicates that it is only searching
the default typelib directory.
@end deffn

@deffn Procedure prepend-search-path! directory
Given @var{directory}, a string representation of a filesystem
directory, this prepends that directory to the typelib search path.

This change doesn't affect libraries loaded before it. It therefore is
advisable to put such directives at the start of a script.
@end deffn

@deffn Procedure infos lib
Fetches all top-level metadata entries of @var{lib}.
@end deffn

@deffn Procedure info lib name
Searches @var{lib} for an entry with name @var{name} and returns it.
Throws an error, if @var{name} could not be found.
@end deffn

@deffn Procedure load (info <GBaseInfo>)
@deffnx Procedure load (info <GBaseInfo>) flags
Generates bindings for @var{info}.

@var{flags} is a logical or of @code{LOAD_METHODS}, @code{LOAD_SIGNALS},
@code{LOAD_PROPERTIES} and @code{LOAD_FIELDS}
and may be 0 or @code{LOAD_INFO_ONLY} tells @code{load}, how to handle
infos with nested information, such as structs and objects.
They enable loading of methods, signals, properties and fields respectively.
By default, all of them are loaded.

@quotation Warning
@code{LOAD_FIELDS} currently does nothing, as fields are not yet supported.
@end quotation
@end deffn

@deffn Procedure load-by-name lib name [flags]
A convenience function composing @code{info} and @code{load}.
@end deffn

@deffn Procedure typelib->module module lib [version]
Loads all infos of @var{lib} into @var{module} and adds them to its public
interface.

@var{module} may be a module or a list of symbols. If the latter is given,
it is resolved to a (potentially new) module. In either case, the resulting
module is returned.

If @var{version} is given, loads that version, otherwise loads the latest.
Throws an error, if the library could not be found or loaded.
@end deffn

@c -----------------------------------------------------------------
@node Typelib Documentation
@section Typelib Documentation

@deffn Procedure typelib lib [version] [#:require?=#t]
Open a new input port, whose contents describe the runtime bindings created
for @var{lib}. If @var{version} is given, use that version of the typelib,
otherwise the latest. If @var{require?} is true (the default), require
it first.
@end deffn

@deffn Procedure gir lib version
Open a new file input port for the GIR metadata of LIB. VERSION applies just
as with @code{typelib}, but is required.
@end deffn

@deffn Parameter gir-search-path
Search path, that @code{gir} searches GIR metadata in.
This parameter is actually defined in @code{(gi config)}.
@end deffn

@deffn Procedure parse xml [documentation]
Parse @var{xml} into a structure suitable for post-processing.
If @var{documentation} is given, use it as a base, merging the two.

@var{xml} is expected to be a string or port containing documentation
in an XML format. @var{documentation} should either be the empty list
(the default) or the result of a previous @code{parse} operation.

It should be noted, that the order in which documentations are
threaded through @code{parse} matters. The last @code{xml} ``wins''
in cases where multiple ones fill in the same value (e.g. attributes).
Since GIRs has more information than typelibs, you should therefore
handle typelibs first in most cases.

The result is a nodeset corresponding to the (merged) XML.
However, it is stripped down to only contain nodes relevant for
documentation (the exact subset may be subject to change) and also
contains the non-standard @code{scheme} node for bindings created
by Guile-GI.
@end deffn

@deffn Procedure ->guile-procedures.txt documentation
Display @var{documentation} in an @file{guile-procedures.txt}-esque style.
@end deffn

@deffn Procedure ->docbook documentation
Display @var{documentation} as DocBook XML.
@quotation Warning
The standard DocBook tools installable through most distributions do
not handle XML, but rather SGML.
Trying to postprocess the results of this function with them will
only end up in weird results, (potentially lots of) errors and user frustration.
Use GTK-Doc instead, either directly or through @code{xsltproc},
or use your own XSLT stylesheets.
@end quotation
@end deffn


@c -----------------------------------------------------------------
@node GObject Types
@section GObject Types

For integer and string arguments, the C to Guile conversions are the
obvious ones. But for the specialized GObject types, things get a bit
more complex.  GObject has three classes of custom types: structs,
unions, and objects.

GObject @emph{unions} and @emph{structs} are handled in Guile-GI by
creating a GOOPS type that wraps a C pointer.  Typically,
instances can be created and by GObject functions and used as
arguments, but, their contents aren't otherwise modifyiable.  GObject
unions and structs may have GObject Methods, but do not have signals
or properties. @xref{GObject Methods} for more information.

GObject @emph{objects} are also stored by creating a GOOPS
type that wraps a C pointer.  Unlike GObject structs and unions, they
have more interactivity available at the Guile layer.  They have
properties that can be queried and Guile procedures can be hooked into
the GObject callback layer, which GObject calls ``signals''.

For each custom GObject type, Guile-GI creates a variable that holds
the GOOPS type.  That variable has the form @code{<TYPE>},
where TYPE is the GObject type name. To check whether an object
has a given type, use the @code{is-a?} procedure found in GOOPS, which
Guile-GI re-exports.

@example
(use-modules (gi))
(use-typelibs ("GObject" "2.0") ("Gio" "2.0"))
(is-a? (make <GApplication>) <GObject>)
;; => #t
@end example

Each GObject struct, union, or object has a place in the GObject
single-inheritance class structure.  A @code{RadioButton} is a type of
@code{Button} is a type of @code{Widget}, for example.  If you wish to
introspect a GObject's type, use @code{get-gtype} and then use the GType
procedures. @xref{GType}.

@c -----------------------------------------------------------------
@node GType
@section GType

A @code{<GType>} is a Guile type, which corresponds to a @code{GType}.
A @code{GType} is basically an integer ID (an @code{<integer>} in Scheme),
that GObject uses to identify a type.

GObject has its own custom class structure.  The following procedures
provide information about how a @code{<GType>} forms part of that
class structure.

@deffn Procedure get-gtype object
Given @var{object}, a GObject struct, union, or object, this procedure
returns its GObject type as an @code{<integer>}, otherwise it returns @code{#f}.
@end deffn

@deffn Procedure gtype-get-scheme-type gtype
Given @var{gtype} of type @code{<integer>}, this procedure will return
the Scheme type that holds instances of that type.
@end deffn

@deffn Procedure gtype-get-name gtype
Given @var{gtype} of type @code{<integer>}, this procedure returns
a string with GObject's internal name for this type.  This may differ
slightly from the name that Guile-GI gives to the type.
@end deffn

@deffn Procedure gtype-get-parent gtype
@deffnx Procedure gtype-get-children gtype
These procedures return the parent type and the child types of a
specified @var{gtype}.
@end deffn

@deffn Procedure gtype-is-a? object type
Returns @code{#t} of @var{object} is an instance of a @var{type}.
@end deffn

@c -----------------------------------------------------------------
@node GObject Methods
@section GObject Methods

Guile-GI exports object methods as GOOPS methods in the formats
@code{type:method} and @code{method}, where @var{type} is the
type of an object sans namespace translated into @code{kebab-case} and
@var{method} is the name of the method translated into
@code{kebab-case}. For instance @code{gtk_widget_show}
is bound to both @code{widget:show} and @code{show}.

Use whichever bindings you prefer or alternatively rename them using the
@code{#:rename} argument to @code{use-modules} or
@code{use-typelibs} respectively. Note that Guile currently warns if a binding
is imported from multiple libraries (e.g. both GLib and Gtk), but this should
not concern you in most cases, as both internally specialize the same generic method.

@c -----------------------------------------------------------------
@node GObject Signals
@section GObject Signals

GObjects have a functionality for defining and calling callback
procedures that it calls @emph{signals}.  Note that these signals
have nothing to do with Unix signals like @code{SIGTERM}.

To hook a callback procedure to an object's signal, use the
@code{connect} procedure. Consider the following example.

@example
(define (activate app)
   ...
   )

(define activate-signal (make <signal> #:name "activate"))

(connect app              ; A GObject
         activate-signal  ; A <signal> object
         activate)        ; A procedure to call when emitted
@end example

In that example, the caller is attaching a procedure named
@code{activate} to the object @code{app}'s ``activate'' signal.  When
the gobject object calls all the callback procedures attached to its
``activate'' signal it will call this @code{activate} procedure.

When a callback procedure is called it may receives some arguments
from the caller and some from user data.  In the example, @code{activate}
is supposed to take a single argument.
This argument -- @code{app} -- is supplied by the caller, as are all
arguments to signals.

@deffn Procedure connect obj (signal <signal>) (handler <procedure>)
@deffnx Procedure connect obj (signal <signal>) (detail <symbol>) (handler <procedure>)
@deffnx Procedure connect-after obj (signal <signal>) (handler <procedure>)
@deffnx Procedure connect-after obj (signal <signal>) (detail <symbol>) (handler <procedure>)
Hooks @var{handler} to emissions of @var{signal}.
If @var{detail} is supplied, only emissions in which the detail matches it are considered.

@code{connect-after} works like @code{connect}, except that the handler is run @emph{after}
the main handling code.
@end deffn

Signal objects can also be used to emit signals. Note that you shouldn't normally do this when
using objects of types, that you didn't define, and even when using objects of types,
that you did define, you should only emit the signals that you defined for that object
(and perhaps the ``notify'' signal when using explicit notification).

@defspec signal obj [detail] [args...]
Emits the @var{signal} signal of @var{obj} with @var{detail} and @var{args}.
Note, that the interpretation of @var{detail} depends on whether or not @var{signal} is detailed.
If it is, @var{detail} needs to be a symbol, that will be translated to the detail of the emission.
If it is not, it is considered the first argument and will be consed with @var{args} to form
an argument list.
@end defspec

Signals have several slots, that can be bound on creation time
(and reassigned freely, since they are proper GOOPS objects).
When connecting signals, only @var{name} needs to be supplied.
When using them as proper signals, at least @var{return-type} needs to be given as well.

@defvr Slot name
The name of the signal.
A string.
@end defvr
@defvr Slot return-type
The return type of the signal.
A @code{<GType>} or integer.
@end defvr
@defvr Slot param-types
The parameter types of the signal.
A list of @code{<GType>}s or integers.
@end defvr
@defvr Slot accumulator
A procedure, called with two arguments @var{seed} and @var{current} and
produces up to two output values.
If it produces no output value, @var{seed} is left unchanged and signal handling
continues.
If it produces one output value, @var{seed} is set to that value and signal handling continues.
If it produces two output values, @var{seed} is set to the second output value and signal
handling stops if the first is @code{#f}.
If at any time @var{seed} would be set to an incorrect value or more than two values are returned
signal handling is aborted.
@end defvr
@defvr Slot flags
Signal flags, a logical or of  one or more of
@code{SIGNAL_RUN_FIRST}, @code{SIGNAL_RUN_LAST},
@code{SIGNAL_RUN_CLEANUP}, @code{SIGNAL_NO_RECURSE}, etc.
@c TODO: refer to the GObject manual
@end defvr

@c -----------------------------------------------------------------
@node GObject Properties
@section GObject Properties

GObject objects may have one or more properties, which are variables
attached to the object that may be gotten or set.  GObject properties
usually have C-like types.  Remember that GObject objects are
instances of a class that may have a parent class, and each parent
class may one or more properties. So, for example, if the object is a
radio button, you may get or set properties that apply specifically to
radio buttons, or generic buttons, or generic widgets.

In Guile-GI, properties come in two flavours.
The basic building block are objects derived from @code{G_TYPE_PARAM} alias @code{<GParam>}.
These can be created via introspected methods found in the @code{GObject} library.
They are enhanced so that they can work as procedures with setter.
Given an arbitrary property @code{prop},
@code{(prop obj)} will fetch the corresponding property, whereas
@code{(set! (prop obj) val)} will set it.

The other flavour are GOOPS accessors.
These are used for introspected properties, so that the name may also overlap with a
method or a signal of a different type. Other than that, they behave no different from
@code{<GParam>}s -- in fact, they work by constructing a @code{<GParam>} and using their
getters and setters.

@node Custom GObjects
@section Defining new GObject classes

Usually any GObjects you use will be created by procedures such as
@code{window:new}, and those GObject types will have been predefined
in the typelib. But, it is possible to make custom GObject object
classes using the @code{register-type} procedure.

Bear in mind, that while Guile-GI internally uses GOOPS, GObjects implemented in it
are not quite as flexible. For instance, you can not meaningfully redefine a
GObject-based type, which you could if you just used GOOPS types.
On the other hand, you can make use of the features of the GObject infrastructure,
such as signals.

Defining a new GObject class is rather complicated.

@deffn Procedure register-type type-name parent-type list-of-properties list-of-signals disposer
This procedure creates and returns a new @code{<GType>} of a GObject
object.

@var{type-name} is the string name of the new type. Note, that it will be
turned into a symbol internally.

@var{parent-type} is the @code{<GType>} of the parent class to this
class.  The parent class needs to be @code{<GObject>} or a GObject
class that descends from it.

@var{list-of-properties} is a list of parameter specifications.
These parameter specifications can be created using the @code{param-spec-TYPE}
methods found in the @code{GObject} typelib.

@var{list-of-signals} is a list of signal specifications. @xref{GObject Signals}.
@end deffn

To then make instances of your custom GObject type, use @code{make}.

@c ----------------------------------------------------------------
@node Enums and Flags
@section Enums and Flags
While GObject is an OOP framework and as such mainly focuses on objects, there
also exists functionality to deal with enumerated types.
Enumerated types are a way of converting raw numbers into meaningful expressions
and broadly fit into two categories: enumerations and flags.
Both assign tokens to numerical values at compile time, but their xuse is different.
Enumerations are used for equality checks only, whereas flags can be composed
through bitwise or, tested by bitwise and, and operated on in other ways -- as long
as the basic operations are bitwise, the result will make some sense.

In Scheme, the closest analogues to enumerations and flags are symbols and symbol lists.
Symbol equality can be checked with @code{eq?}, symbol list equality with @code{equal?}
and in Guile specifically, the other operations can be implemented based on the @code{lset-*}
procedures.@footnote{Other implementations may offer similar functions -- otherwise they
can be implemented by the user themselves.}
However, both of these lose information needed to convert them into a numerical representation.

In Guile-GI, we bind enumerations and flags to GOOPS objects as we do with every
other object type. Specifically, enums derive from @code{<GEnum>} and flags derive from @code{<GFlags>}.

@subsection Conversions
@deffn Procedure number->enum (class <class>) (number <number>)
@deffnx Procedure number->enum (class <class>)
@deffnx Procedure number->flags (class <class>) (number <number>)
@deffnx Procedure number->flags (class <class>)
@deffnx Procedure number->@var{type} (number <number>)
Converts @var{number} into an enum or flags of class @var{class}.
Called with just @var{class}, produces a procedure, that can be used
to call itself with just @var{number}.This is often referred to as currying.

number->@var{type} calls the appropriate constructor for the given type. Note, that this
type is shortened to its name without any prefixes.
For instance, a @code{GtkOrientation} may be created using @code{number->orientation}.
We will henceforth refer to this construction as ``binding @var{class} on @var{type}''
@end deffn

@deffn Procedure symbol->enum (class <class>) (symbol <symbol>)
@deffnx Procedure symbol->enum (class <class>)
@deffnx Procedure symbol->var{type} (symbol <symbol>)
Converts @var{symbol} into an enum of class @var{class}.
Curries. Binds @var{class} on @var{type}.
@end deffn

@deffn Procedure list->flags (class <class>) (list <list>)
@deffnx Procedure list->flags (class <class>)
@deffnx Procedure list->var{type} (list <list>)
Converts @var{symbol} into flags of class @var{class}.
Curries. Binds @var{class} on @var{type}.
@end deffn

@deffn Procedure enum->number (enum <GEnum>)
@deffnx Procedure enum->number (class <class>) (enum <GEnum>)
@deffnx Procedure enum->number (class <class>) (symbol <symbol>)
@deffnx Procedure enum->number (class <class>)
@deffnx Procedure @var{type}->number (class <class>)
If @var{symbol} is given, returns the value represented by @var{symbol}
in @var{class}.

If @var{enum} is given, converts it to a symbol.
If both @var{enum} and @var{class} are given, raises an error
if @var{enum} is not of type @var{class}.

Curries. Binds @var{class} on @var{type}.
@end deffn

@deffn Procedure enum->symbol (enum <GEnum>)
@deffnx Procedure enum->symbol (class <class>) (enum <GEnum>)
@deffnx Procedure enum->symbol (class <class>)
@deffnx Procedure @var{type}->symbol (class <class>)
Converts @var{enum} to a symbol. If @var{class} is given, raises an error
if @var{enum} is not of type @var{class}.
Curries. Binds @var{class} on @var{type}.
@end deffn

@deffn Procedure flags->number (enum <GEnum>)
@deffnx Procedure flags->number (class <class>) (enum <GEnum>)
@deffnx Procedure flags->number (class <class>) (list <list>)
@deffnx Procedure flags->number (class <class>)
@deffnx Procedure @var{type}->number (class <class>)
If @var{list} is given, returns the value represented by @var{list}
in @var{class}.

If @var{flags} is given, converts it to a symbol.
If both @var{flags} and @var{class} are given, raises an error
if @var{flags} is not of type @var{class}.

Curries. Binds @var{class} on @var{type}.
@end deffn

@deffn Procedure flags->list (enum <GEnum>)
@deffnx Procedure flags->list (class <class>) (enum <GEnum>)
@deffnx Procedure flags->list (class <class>)
@deffnx Procedure @var{type}->list (class <class>)
Converts @var{flags} to a list of symbols. If @var{class} is given, raises an error
if @var{flags} is not of type @var{class}.
Curries. Binds @var{flags} on @var{type}.
@end deffn

@subsection Standard Procedure overrides
@code{<GEnum>} and @code{<GFlags>} display as their symbolic/list representation
and also use them in write in lieu of their addresses.
Enumerations can be numerically compared to enumerations and numbers using @code{=}.
Flags can be numerically compared to flags and numbers using @code{=}.
Enumerations and flags can be compared to enumerations and flags of the same type using
@code{equal?}.

@subsection R6RS-esque flag operations
Some would certainly like to see an equivalence the enumerated types discussed above and
R6RS enum sets. However, it turns out, that they are not compatible.
Enumerations are not enum sets, because they are not sets -- they are atoms.
Flags are not enum sets, because they don't have a universe.
Instead, they have a numerical mask.
In an enum universe, each value is distinct from any other. GObject flags can however
be combinations of other flags.
A commonly found pattern is @code{SOME_READWRITE = SOME_READ | SOME_WRITE} for example.
Hiding @code{'readwrite} would take a lot of work just so we can explicitly go against the
design of the library writer, which is not a good idea at all.

To cope with this fact, we implement our own -- similar, albeit somewhat different --
set of functions, that aim to be close to what you see in R6RS.

@deffn Procedure flags-mask (class <class>)
@deffnx Procedure flags-mask (flags <GFlags>)
Returns flags of class @var{class}, that has all possible values set.
If @var{flags} is given, @var{class} is inferred from it.
@end deffn

@deffn Procedure flags-union (flags <GFlags>) . rest
Constructs the union of all flags given by @var{flags} and @var{rest}.
All of them must belong to the same class.
@end deffn

@deffn Procedure flags-intersection (flags <GFlags>) . rest
Constructs the intersection of all flags given by @var{flags} and @var{rest}.
All of them must belong to the same class.
@end deffn

@deffn Procedure flags-difference (flags1 <GFlags>) (flags2 <GFlags>)
Constructs the difference of @var{flags1} and @var{flags2}.
Both of them must belong to the same class.
@end deffn

@deffn Procedure flags-complement (flags <GFlags>)
Returns the flags not set in @var{flags}.
@end deffn

@deffn Procedure flags-set? (flags <GFlags>) (number <number>)
@deffnx Procedure flags-set? (flags <GFlags>) (symbol <symbol>)
@deffnx Procedure flags-set? (flags <GFlags>) (list <list>)
Return @var{#t} if and only if the flag(s) given by @var{number}, @var{symbol}
or @var{list} are set.
@end deffn

@deffn Procedure flags-projection
@deffnx Procedure flags-projection/list (flags <GFlags>) (class <class>)
@deffnx Procedure flags-projection/list (flags <GFlags>) (flags2 <GFlags>)
@deffnx Procedure flags-projection/number (flags <GFlags>) (class <class>)
@deffnx Procedure flags-projection/number (flags <GFlags>) (flags2 <GFlags>)
Project @var{flags} onto class @var{class}. (@var{class} is inferred from @var{flags2}).

@code{flags-projection/list} constructs flags from all symbols in @code{(flags->symbol flags)},
that are valid in @code{class}.
@code{flags-projection/number} constructs flags, that have the same bits set with respect to
@code{(flags-mask class)}.

@code{flags-projection} is an alias for @code{flags-projection/list}.
@end deffn

@c ----------------------------------------------------------------
@node Utilities
@section Utilities

@deffn Procedure push-duplicate-handler! handler
Adds @var{handler} to the default duplicate handlers at the start of the list.
@end deffn

@defvr {Duplicate handler} shrug-equals
A handler, which silently accepts equal (as in @code{eq?}) bindings.
@end defvr

@deffn Procedure protect symbol [prefix] [suffix]
@deffnx Procedure protect* symbols [prefix] [suffix]
Returns a renamer, which ``protects'' @var{symbol}, a symbol or @var{symbols},
a list of symbols from being overridden, by prepending prefix and appending suffix,
both symbols.
If neither prefix nor suffix are given, @code{'%} is used as prefix.
@end deffn

@c ----------------------------------------------------------------
@node More Stuff
@section More Stuff

@subsection On Guile to C Type Conversions
Guile-GI uses a rule system to convert Guile procedure arguments to C
types.  Typically these conversions between Guile and C types are
straightforward, but, some conversions are tricky and need additional
description.

@subsubsection Strings
GObject libraries usually use UTF-8 encoding for their strings, while
Guile uses a different encoding internally for its strings.  Thus
every time a string is parameter is passed through to a C procedure, a
new UTF-8 copy of the Guile string is created.  The string is
automatically freed when no longer in use.

GObject has some procedures that deal with locale-encoded strings:
notably those procedures that deal with environment variables.
Guile-GI converts Guile strings to locale-encoded strings for those
procedures.  Note that this may throw an encoding error if the Guile
string cannot be represented in the current locale.

@subsection C Arrays
There are many different types of C arrays, and the Guile types
expected for GObject procedures that C arrays varies depending on the
type required.

Typically, for simple C arrays of numerical types -- integers, floating
points, etc -- a Guile bytevector needs to be used.  For these
bytevectors, always use native-endianness.

For C arrays of GObject objects, structs, unions, flags, enums, and
GTypes, a @emph{list} is used instead of a bytevector.

If the C procedure expects a zero-terminated array, Guile-GI will
provide that automatically.  There is no need to add you own zero.

Some GObject procedures write output information into preallocated C
arrays.  For those procedures, the Guile caller will need to create
and pass in a bytevector of the appropriate size.

@quotation Warning
It is best not to use any of GLib's @code{Array} and @code{ByteArray}
procedures directly.  Since arrays get converted to bytevectors, these
procedures will likely fail to do anything sensible.
@end quotation

@subsection Help! Guile-GI overrides core binding X
In most cases this is nothing to worry about. Guile-GI ensures, that
the core binding is used as the default behaviour when the signature
does not accidentally match that of a function in some typelib.
However, this can still cause issues when Guile-GI overrides syntax.
To protect your syntax (or other variables you deeply care about), use
the @code{protect} or @code{protect*} renamer from @code{(gi util)}.

@subsection Help! Guile-GI bindings conflict with each other
Most conflicts should be resolved using the @code{merge-generics} duplicate handler.
However, this handler is not enabled by default, so you may want to push it to the
default duplicate handlers. If this is still not working, you may somehow have ended up
with ``equal'' duplicates, i.e. duplicates, whose bindings resolve to the same value.
To silence warnings about them, use the @code{shrug-equals} duplicate handler
defined in @code{(gi util)}.
If the conflict is still not resolved, file a bug detailing it.
As a workaround, you may also rename either binding, which is probably the best way
to resolve a duplicate.

@node Further Resources and Contact Info
@chapter Further Resources and Contact Info

Uh, I dunno.

Maybe the Guile mailing list?

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl-1.3.texi

@node Index
@unnumbered Index

@printindex cp

@bye
